 1. Generating random numbers
    -- Uniform
    -- Normal
    -- Binomial
    -- Exponential
 2. Using `sample`
 3. d*, p* and q* functions

 ***

  Случайностите в живота не са лесни за постигане. Въпреки това, днес ще си
  поставим сериозната цел да генерираме случайни числа.

  Случайно число е такова число, чиято стойност няма как да разберем преди
  избора му. Зад това просто твърдение се крие всичката криптографска
  сигурност на нашия свят. Освен, че едно случайно число трябва да е
  непредвидимо, то трябва да следва и дадено разпределение. Разпределенията
  показват каква е вероятността, че ще изберем точно определено случайно
  число. В теорията на вероятностите съществуват много разпределения, но ние
  ще се спрем на четири от тях: равномерно, нормално, биномно и
  експоненциално. Ще разберем кога биха ни били нужни и как с помощта на R да
  генерираме случайни числа съответстващи на дадено разпределение. 

  Да вземем един зар и да го хвърлим хиляда пъти, записвайки падналата се
  стойност на всяко хвърляне. Понеже да напишем 1000 числа ще заеме твърде
  много място, ще начертаем една възможна хистограма генерирана от данните ни:

 150-| +---------+           +---------++---------+           +---------+      
     | |         |+---------+|         ||         |+---------+|         |      
 100-| |         ||         ||         ||         ||         ||         |      
     | |         ||         ||         ||         ||         ||         |      
  50-| |         ||         ||         ||         ||         ||         |      
     | |         ||         ||         ||         ||         ||         |      
   0-| |_________||_________||_________||_________||_________||_________|      
             ______________________________________________________            
            |          |          |          |          |          |           
            1          2          3          4          5          6           

  Виждаме нещо доста интересно - стълбовете на хистограмата са на почти
  еднаква височина. Нека видим какво представлява графиката. По хоризонталата
  имаме падналата се стойност от зара - 1,2,3,4,5,6. По вертикалата имаме
  колко пъти се е паднала дадената стойност. Понеже вероятността да се падне
  всяко число на зара е еднаква, нормално е да очакваме, че като направим 1000
  хвърляния, броят на паданията на всяка стойност ще е почти еднакъв. Това
  какво ще ни се падне от зара е нашата _случайна величина_. Като добавим към
  нея честотите на паданията, получаваме _разпределението_ ѝ. В случая, това
  разпределение се нарича равномерно. То се отнася за такива случайни величини,
  за които е еднакво възможно да се паднат в даден диапазон.

  С R много лесно можем да генерираме равномерно разпределени случайни числа:

    > runif(1, 1, 6) # Едно число в интервала [1,6]
    > runif(5, 1, 6) # Пет числа
    > runif(10) # Десет числа в интервала [0,1]

  А сега ще генерираме 1000 случайни числа и ще начертаем тяхното
  разпределение:

    > nums = runif(1000, 1, 10)
    > hist(nums, prob=T, col=gray(.9), main="Numbers in [1,10]")
    > curve(dunif(x, 1, 10), add=T)

  Функцията `dunif` дава плътността на равномерното разпределение. В случая, 
  тя е

             f(x) = 1 / (max - min) = 1 / (10 - 1) = 1/9

  С `curve` чертаем плътността върху графиката.

  Сега, нека се запознаем с Ийори - магаренцето от Мечо Пух. Преди да се
  карамелизираме от сладост, ще кажа че Ийори е много сериозно магаренце! То
  всяка сутрин излизало да тича из гората, а след това се занимавало с наука!
  И макар, че изглежда доста глуповато, Ийори било умно магаренце
  заинтересувано от това колко товар могат да носят неговите събратя на гърба
  си. То ежедневно събирало и събирало данни. В крайна сметка, получило нещо,
  което би могло да се изрази с нормално разпределение:

    > weight = rnorm(100, mean=30, sd=3)
    > hist(weight, prob=T, col="cyan3", main="Eeyore's study")
    > curve(dnorm(x, mean=30, sd=3), add=T)

  Нормалното разпределение се крие зад много от класическата теория на
  статистиката. Огромно количество случайни събития биха могли да се изразят с
  него.

  Ийори не било само в своите научни приключения. Често самият Мечо Пух го
  посещавал, слушайки тежки грайндкор ритми. По време на едно такова
  посещение, двамата решили да четат за Бернули и неговите опити. Бернули,
  освен че учил бизнес и медицина, бил голям математик. В основата на неговите
  проучвания била страстта му да се занимава с подхвърляне на монети. Той
  подхвърлял ли, подхвърлял, докато не се сетил, че всъщност прави Бернулиеви
  опити. Какво представлявали те? Ами, експерименти, при които или получаваш
  истина, или лъжа.

  В R много лесно можем да подхвърляме монети (дори не ни трябват пари!):

    > n = 1; p = 0.5
    > rbinom(1, n, p) # Хвърли една честна монета!
    >
    > rbinom(10, n, p=_0.2_) # Хвърли десет _нечестни_ монети!

  След малко ще разберем каква роля играе нашият параметър `n`. За сега ще
  разгледаме `p`. Какво е то? Ами, то е нашият шанс за успех. Където успех е
  доста разтегливо понятие, щото с него можем да означим събития като губене
  на голяма сума пари, случването на катастрофа и въобще кофти ситуации.

  Нека си представим какво би се случило, ако вместо от всяко отделно хвърляне
  на монета, се интересуваме от броя на успешните хвърляния на монета в `n`
  опита. Ами, получаваме Биномно разпределение.

  Така, при Бернулиевото разпределение, правим 1 опит и се интересуваме от
  това дали той е успешен. При Биномното разпределение, правим `n` опита и се
  интересуваме колко от тях са успешни. Например, Пух и Ийори се зачудили ако
  тръгнат из гората и обиколят 10 _случайни_ дървета, на колко от тях ще има
  кошер с мед. Това било Биномен експеримент. Неговата вероятност за успех `p`
  била 0.42 поради подробните проучвания на темата от различни горски учени.
  Как можем да генерираме едно примерно обхождане на Пух и Ийори из гората с
  R?

    > n=10 # Обикаляме 10 дървета, правим 10 опита
    > p=0.42 # Вероятността да успеем във всеки опит е 0.42
    > rbinom(1, n, p) # След 1 обикаляне, колко успеха имаме?
    > rbinom(6, n, p) # А след 6 обикаляния на 6 различни гори?

  # TODO: Explain better
  Сега, биномното разпределение е дискретно. Това ще рече, че с него описваме
  експерименти, където работим с краен брой изходи от всеки опит, който
  правим. Следователно, неговата плътност не може да се опише с крива, защото
  имаме дупки между всяка получена стойност. Поради тая причина, ще използваме
  нашата функция drawBinomial(n, p), с която ще начертаем три хистограми, с
  техните плътности в R:

    > source("drawBinomial.R") # Зареди функцията
    > par(mfrow = c(1,3))
    > drawBinomial(5, 0.42)
    > drawBinomial(15, 0.42)
    > drawBinomial(50, 0.42)

  Виждаме, че с нарастването на `n`, нашите данни започват доста да приличат
  на нормално разпределени.

  Излизаме от гората на Пух и Ийори и отиваме при Кристофър Робин. Чупейки
  всякаква невинност у вас, ще споделя, че Робин бил вманиачен по компютрите.
  Той поддържал сървърна ферма със 100 машини. На базата на редовни проучвания
  видял, че средно един сървър му пада на три месеца. Кристофър събрал данните
  си във вектор servers, чиито стойности може да видите във файла
  servers_data.R. Той ги начертал с една хистограма:

    > source("servers_data.R")
    > hist(servers, prob=T, col=rainbow(10), main="Servers lifetime",
    + xlab="Lifetime in months")

  Момчето забелязало, че разпределението на живота на сървърите му било доста
  интересно. Наистина, това разпределение се нарича експоненциално и
  обикновено се ползва за разглеждането на случайни величини от сорта на
  времето за чакане до дадено събитие или пък натрупването на дадено
  количество до случването на дадено събитие. Например, времето за чакане на
  опашка, количеството мръсни чорапи в стаята, което е нужно да се натрупа до
  създаването на империя от микроорганизми или пък средното време за отговор
  на заявка от даден сървър. В R лесно генерираме случайни величини, които са
  експоненциално разпределени:

    > socks = rexp(100, 1/10) # Средно 10 мръсни чорапа

  Вторият параметър на rexp е rate-a, с който се случва даденото събитие.
  Формулката за получаването му е 1 / mean.

    > hist(socks, prob=T, col=terrain.colors(10))
    > curve(dexp(x, 1/10), add=T)

  Кристофър Робин, освен че страшно много се кефил на компютрите, обичал и
  хазарта. Един ден, играейки белот на вързано, Робин се замислил как може да
  използва своите компютри за генериране на възможни резултати от хазартни
  игри. Погледнал в документацията на R (или, както се казва, RTFM) и забелязал
  функцията `sample`. Смисълът на тази функция бил от някакъв вектор с данни
  да изважда на случаен принцип елементи от него. Например, ето как ще хвърлим
  едно зарче 10 пъти:

    > sample(c(1:6), 10, replace=T)

  С `replace=T` казваме, че нямаме нищо против `sample` да генерира данни с
  повторение. В случая, това е окей - ние хвърляме едно и също зарче и
  следователно е възможно някои от хвърлянията да дават един и същ резултат.
  Ако играехме тото, обаче, ние няма как да изберем няколко едни и същи числа.
  За това използваме `sample`, където `replace=F`. По подразбиране,
  `replace=F`.

    > sample(c(1:54), 6)

  И накрая, защо не видим с каква ръка на покер може да се сдобие Кристофър?

    > numbers = c("A", 2:10, "J", "Q", "K")
    > suits = c("H", "D", "S", "C")
    > cards = paste(rep(numbers, 4), suits) # събери всеки 13 числа с тяхната боя
    > sample(cards, 5)

  Накрая, извън всякакъв контекст, ще се запитаме следното: Ако имаме някаква
  случайна величина и нейното разпределение, как можем да разберем вероятности
  свързани с нея?
  
  Например, нека имаме нормално разпределена случайна величина, която е в
  резултат от измерването на количеството игра на малки котенца в часове. Тя е 
  със средно 7.3 часа и стандартно отклонение 1.2 часа. С функцията `pnorm` 
  можем да намерим отговора на въпрос от сорта на: Какъв е шансът котенце да
  си играе по-малко от 7 часа на ден:

    > pnorm(7, mean=7.3, sd=1.2)

  Или пък да си играе повече от 9 часа на ден:
    
    > 1 - pnorm(9, mean=7.3, sd=1.2)
    > pnorm(9, mean=7.3, sd=1.2, lower.tail=F) # нека pnorm да направи
    + изваждането

  Друг въпрос, на който можем да си отговорим е: На дадена вероятност, колко
  часа на ден игра максимум съответстват. Това става с функцията `qnorm`,
  която един вид прави обратното на `pnorm`:

    > qnorm(.75, mean=7.3, sd=1.2) # до колко часа игра имат 75% от котенцата
