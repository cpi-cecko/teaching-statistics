 1. Data frames
    -- Storage
    -- Usage
    -- Manipulation
 2. Viewing multivariate data
    -- n-way contingency tables
    -- Barplots
    -- Boxplots
    -- Stripcharts
    -- Violinplots & densityplots
    -- Scatterplots

 ***
  
  Понякога на конкретен статистик му идва в главата въпроса за това как да
  съхранява и работи с многомерни данни. После настъпва въпроса за това колко
  е сложен живота. След това се появява типичното за студента примирение и
  живота остава на течението от прозорците на новоремонтирания блок 52.

  Та, в R е лесно и приятно да се работи с многомерни данни, благодарение на
  командата ``data.frame''.

  Нека си представим, че студентът от богословския факултет, Герасим, прави
  проучване за качеството на чорапите в своето общежитие. Той обикаля по
  стаите и събира данни за - престой в дни, индекс на мирис, липсващ втори
  чорап. Събраните данни ги представя в четири вектора:

    > age = c(5,1,4,8,7,4,4,3,6,5,3)
    > smell = c(1,0,1,3,2,2,3,1,2,3,2)
    > paired = c("T","T","T","F","F","T","F","F","T","T","F")

  Тези данни представляват проучването на единадесет чорапа и могат да се
  представят във вида на квадратен масив, чрез data.frame:

    > socks = data.frame(age, smell, paired)

  Колоните в този масив са именувани спрямо имената на векторите, които
  подаваме. Ако желаем можем да променим имената им:

    > socks = data.frame(възраст=age, мирис=smell, чифт=paired)

  Също така, ако имаме лично отношение към данните си, можем да именуваме
  всеки ред в нашият масив:

    > row.names(socks) <- c("Пешо", "Яна", "Яна 2", "Яна 3", "Иван", "Иван
    + 100", "Димитрич", "Юрий", "Ицо Петроф", "Светльо", "Чужденецът")

  Има няколко начина да достъпваме нашите данни. Първият е във вид на масив,
  вторият във вид на списък и третият е комбинация между двата.

  Та, ако искаме да видим възрастите на всеки чорап, можем да го направим по
  два начина:

    > socks[,'възраст']
    > socks[,1] # 1 - индекс на колоната, която искаме да видим

  Ако искаме да видим повече от една колона, имаме следната опция:

    > socks[,1:2] # n:m - рейндж от индекси

  Ако пък искаме да видим данни за определен именуван чорап и нечии негови
  характеристики, може да използваме следната нотация:

    > socks['Юрий', c(1,3)] # Възраст и чифт на чорапите на Юрий
    > socks['Яна', c('мирис','възраст')] # Яна има късмет днес

  Естествено, може да използваме и списък. Списъкът е множество от обекти. В
  случая, data.frame е списък, чиито обекти са вектори. За да достъпваме
  елементи на един списък, ние използваме или знака '$', или [[<име>]].

    > socks$мирис
    > socks[['чифт']]
    > socks[[1]]

  И накрая, можем да избираме данни по някакъв критерий:

    > socks[socks$чифт == 'T', ] # Всички чорапи, които имат чифт
    > socks[socks$възраст >= 5, 'мирис'] # Колко миришат старите чорапи?

  Концентрирайки вниманието си върху полето ``чифт'', бихме забелязали, че то
  разделя чорапите на две категории - такива, които имат чифт и такива, които
  нямат. Има два начина да вземем дадена характеристика на чорапите по
  категория. Първият е чрез logical extraction:
   
    > socks$възраст[socks$чифт == "F"] # Колко време му трябва на един чорап да
    + остане сам
    > socks$възраст[socks$чифт == "T"] # А може ли да не се изгубиш в старостта?

  Този начин обаче е доста тегав, защото за всяка категория трябва да напишем
  страшно много буквички за да се сдобием с нужната информация. По-лесно ще ни
  е да оставим R да направи всичко за нас:

    > unstacked = unstack(socks, възраст ~ чифт) # Разплети категориите с плам
    > boxplot(unstacked) # Плотни, стани ти учен в БАН!

  Та, в тази си проста употреба, unstack взима даден data.frame и от него
  извлича тези списъци, които отговарят на израза след запетаята. Ако имаме
  data.frame от само две колони, функцията подразбира, че трябва да покаже
  пъравата колона спрямо категорията на втората. В случая, PlantGrowth е
  data.frame с две колони - тежест и група за някакви растения. С unstack
  лесно можем да изведем трите типа групи растения:

    > data(PlantGrowth)
    > unstack(PlantGrowth)

  Сега ще визуализираме чорапи.

  Най-простия начин, по който можем да го направим е да си събуем обувките и
  да разгледаме парчетата плат, които обвиват краката ни. Понеже това може да
  е неприятно занимание за повечето от нас, ще се спрем на втория най-прост
  начин - използване на многомерни таблици:

    > table(socks$възраст, socks$мирис)
    > with(socks, 
    +      table(възраст, мирис, чифт)) # Чрез with атачваме data.frame-а socks
    + за да можем по-цивилизовано да ползваме списъците в него

  Следващият начин е да използваме barplot. Понеже изпитваме желание да
  нарисуваме възрастта на чорапите спрямо категорията `чифт', трябва по
  подходящ начин да изкомуникираме това с функцията barplot. Бидейки не много
  комуникативна функция, единствения вариант да видим как бихме направили това
  е чрез ?barplot. Help-ът на R ни казва, че първият параметър на barplot е
  height, който или е едномерен вектор от стойности, или матрица, ако ползваме
  многомерни данни. Какво прави матрици в R? Функцията table:

    > barplot(table(socks$възраст, socks$чифт), beside=T)

  И сега, понеже искаме да сме яки, желаем да видим освен възрастта
  категоризирана по чифт, и мириса категоризиран по чифт:

    > par(mfrow=c(1,2)) # Искаме 1 ред по 2 графики за рисуване
    > barplot(table(socks$възраст, socks$чифт), beside=T)
    > barplot(table(socks$мирис, socks$чифт), beside=T)

  До тук с чорапите. Ще се занимаваме със случайни числа, които са случайни
  дотолкова, доколкото ентропията ни позволява.

  С функцията rnorm ще създадем n на брой случайни числа. После ще ги
  разпределим в 10 категории. След това, ще плотнем всяка категория в отделен
  boxplot. Защо? Ами, за да разберем по-добре какво представлява factor, какво
  е data.frame и как се използва boxplot.

    > rands = rnorm(100)
    > f = factor(rep(1:10, 10))

  Генерирахме 100 случайни числа. f е фактор, представящ 10 категории, на
  които ще съпоставим всяко число. Нека да видим какво ще направи data.frame с
  rands и f:

    > data.frame(rands, f) 
    > unstack(data.frame(rands, f))

  Виждаме как всяко 1, 11, 21, 31... число е в категория 1. Всяко 2, 22, 32...
  число е в категория 2 и така нататък. По този начин групирахме някакви данни
  по някакъв вектор от категории (фактор). Това е същото като примера, в който
  групирахме предполагаемата бързина на триене на фасагена на Женчо спрямо
  времето измерено от полицая (предишната лекция). След тези разяснения, можем
  да начертаем няколко boxplot-a:

    > boxplot(rands ~ f, main="Рандъм зарчета FTW!")

  Подобно нещо можем да направим и със stripchart:

    > stripchart(rands ~ f)

  Разликата е, че stripchart-а е удобен, само когато имаме малко количество
  данни.

  Преди много много време във ФМИ се появил един човек. Той се казвал
  Александър и бил начинаещ мастър програмист. Любовта към статистиката у него
  се зародила след като той съвсем случайно, спейки на четири стола една нощ,
  се събудил и решил да изпие половин бутилка водка. Освен приятно опиянение,
  количеството алкохол в неговата кръв го накарало да се зачуди коя е
  най-добрата сървърна операционна система. И да, обикновено хората си мислят
  за живота като се напият. Е, програмистите си мислят за сървъри и R.

  Та Алекс сетъпнал 24 машини в различни части от София. На всяка от тях
  вървял Apache уеб сървър. На първите 8 машини имало Windows, на следващите -
  Linux, а на последните 8 - FreeBSD. Това били данните за ъптайм на машините
  в дни (и да, числата са измислени):

    > up.time.win = c(10,15,20,23,12,15,6,19)
    > up.time.lin = c(176,313,200,255,355,300,225,315)
    > up.time.bsd = c(213,300,111,345,387,243,210,305)
    > up.time = c(up.time.win, up.time.lin, up.time.bsd)
    > os = c(rep("win", 8), rep("lin", 8), rep("bsd", 8))
    > os = factor(os)
    > benches = data.frame(up.time, os)

  Алекс, чиято фамилия била Велин, се зачудил как да разбере какво му казват
  тия данни. Първата му мисъл била да пита звездите - все пак количеството
  водка, което бил изпил му позволявало това своеволие. Е, отказал се и решил
  да се довери на три типа графики, които били възможни с R. Това били
  boxplot, simple.violinplot и simple.densityplot.

  boxplot-a бил ясен. По-интересна била нуждата от violinplot и densityplot.
  Общо взето, първият позволявал освен да видим разпръсността на нашите данни,
  да обърнем внимание и на тяхната плътност. densityplot-ът пък позволявал да
  сравним няколко плътности спрямо една и съща скала. Нека видим трите графики
  и да преценим на коя какво се вижда най-добре:

    > boxplot(up.time ~ os, data = benches, col = "lightgray")
    > simple.violinplot(up.time ~ os, data = benches, col = "lightgray")
    > simple.densityplot(up.time ~ os, data = benches)

  След като забелязал очеизвадното преимущество на FreeBSD и Linux над Windows
  (no flame-wars intended...), той пожелал да види как up-time-a на всяка една
  от машините се влияе от това с колко бири на вечер запойва своите сисадмини.
  За всяка операционна система, Велин определил две дози бира - 2 и 6
  бири. Данните прибавил към benches и също така обновил up.time вектора:

    > beers = c(2,2,2,2,6,6,6,6,2,2,2,2,6,6,6,6,2,2,2,2,6,6,6,6)
    > up.time.win = c(10,15,18,21,5,7,3,11)
    > up.time.lin = c(355,315,367,300,255,212,150,300)
    > up.time.bsd = c(150,167,114,250,356,378,345,313)
    > up.time = c(up.time.win, up.time.lin, up.time.bsd)
    > benches['up.time'] = up.time
    > benches['beers'] = beers

  След това направил scatterplot:

    > with(benches, plot(up.time ~ beer, pch=as.numeric(os)))
    > legend(locator(1), legend = levels(os), pch = 1:3)

  И така много ясно забелязал, че за Windows броят на бирите не е мотиватор,
  за Linux 2 бири доста помагат, а за FreeBSD 6 бири са перфектният градус.
