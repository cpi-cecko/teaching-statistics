 1. Why simulations?
 2. Simulating the CLT
 3. Normal plots

 ***

  Често бихме желали да симулираме разни работи с R. Днес ще се научим да
  правим точно това.

  Първата задачка, която ще разгледаме е свързана с тежкия въпрос каква е
  вероятността в стая с `n` човека да има двама с рожден ден на една и съща
  дата. Да симулираме решението на тая задача значи да създадем голям брой
  случайни съвкупности от хора и да видим в колко от тях се е случило това
  събитие. Понеже нямаме практическата възможност да се сдобием с много стаи и
  много хора, ще се наложи да си генерираме данните в R. Как ще стане това?
  Ами, най-простият начин е да използваме функцията `sample`. Тя взима някакъв
  вектор от данни и от него ни изважда случайни елементи. Например,
    
    > birthdays = sample(seq(1, 365), 100, replace=T)

  ще ни извади 100 дни от 365, като ще ни позволи да имаме повтарящи се дни.
  Това много приятно симулира ситуацията, в която имаме 100 човека в стая и
  питаме всеки на коя дата е роден.

  Следващото нещо, което ни трябва е да разберем във всяка такава случайна
  извадка, колко дублиращи дни е имало. Това ще стане с функцията
  `duplicates`. Тази функция, имайки за параметър вектор, връща индексите на
  елементите в този вектор, за които има дублиращи се елементи. Това ще рече,
  че следният израз

    > birthdays[duplicates(birthdays)]

  ще ни даде вектор състоящ се само от дублираните рождени дни. Ако този
  вектор е с дължина 0, значи в текущата случайна извадка не е имало двойка
  хора с повтарящи се рождени дни.

  Всичко е много хубаво обаче това беше само един наш опит. За да направим
  качествена симулация трябва да направим много експерименти и да запишем броя
  на успешните експерименти. За целта, ще врътнем един цикъл за всяка
  итерация, на който, ще правим експеримент и ще го броим ако е успешен.

    > duplicateBDays = 0
    > numSims = 1000
    >
    > for (i in seq(1, numSims)) {
    >   birthdays = sample(seq(1, 365), 100, replace=T)
    >   dups = birthdays[duplicates(birthdays)]
    >
    >   if (length(dups) > 0) {
    >     duplicateBDays = duplicateBDays + 1
    >   }
    > }

  Единственото, което ни остава да направим, е да разделим броя на дублиращите
  се рождени дни на общия брой експерименти.

    > prob = duplicateBDays / numSims

TODO: Add simulation about phone calls
 
  Продължаваме с централната гранична теорема (Central Limit Theorem). Тя
  гласи, че при определени условия, сумата и средното аритметично на голям
  брой независими случайни величини ще бъде приблизително нормално
  разпределено, независимо от разпределението на тези случайни величини.
  Естествено, тези случайни величини трябва да имат дефинирано математическо 
  очакване и стандартно отклонение.

  Математически изразено, ако имаме наблюденията Xi взети от популация със
  знайни математическо очакване (mu) и стандартно отклонение (sd), то
  стандартизираното средно:

                           mean(X) - mu
                          --------------
                           sd / sqrt(n)

  E приблизително нормално разпределено със средно mu и стандартно отклонение
  sd.

  Първият въпрос, на който трябва да си отговорим е - Какво представлява
  нормалното разпределение? Ами, то е непрекъснато разпределение, което е
  характерно за голям набор от случайни събития. Формата му е камбановидна и
  симетрична относно математическото очакване.

  Каква е ползата от централна гранична теорема (ЦГТ)? Често ни се налага да
  правим статистически заключения за дадена популация на базата на извадка от
  тази популация. За да си направим тези статистически изводи, ние изчисляваме
  определени функции наречени оценки на извадката. Тези оценки често са суми
  или средни на извадката. Понеже знаем, че, за достатъчно голям брой
  измервания, техните суми или средни са приблизително нормални, то ние можем
  да опишем поведението на тези оценки чрез нормално разпределение и да си
  правим изводи за това колко е вероятно да наблюдаваме някои техни стойности.

  Сега ще видим как можем да симулираме разпределението на резултатите
  получени от ЦГТ.

  Първата симулация, която ще направим, е свързана с биномно разпределение.
  Имаме n биномно разпределени случайни величини и искаме да апроксимираме
  сумата им чрез нормално разпределение. Ако S е биномна разпределена,
  нейното математическо очакване mu е равно на n*p, а стандартното ѝ
  отклонение sd е равно на n*p*q. Тогава, от по-горната формула следва, че
  случайната величина, която апроксимира математическото очакване на тези
  случайни величини, е нормално разпределена и се изчислява чрез следната
  формула:

                               S - n*p
                          -----------------
                           sqrt(n*p*(1-p))

  Нека симулираме това в R за S - биномно разпределена случайна величина
  с n=10 и p=0.25:

    > n=10; p=0.25
    > S = rbinom(1000, n, p) # Генерираме 1000 независими, биномно
    + разпределени случайни величини
    > X = (S - n*p) / sqrt(n*p*(1-p))

  Единственото, което ни остава е да нарисуваме разпределението им за да видим
  доколко то прилича на нормално разпределение:
  
    > hist(X, prob=T, col="cadetblue3")
    > curve(dnorm(x), add=T)

  Виждаме, че получената хистограма доста се приближава до теоретичната
  плътност на нормалното разпределение.

  Както видяхме от предишните симулации, понякога генерирането на един опит
  няма да е толкова просто. Тогава ще трябва да използваме цикъл, в който да
  генерираме опитите си и да прибавяме към някакъв вектор резултатите от тях.
  След като приключим с генерирането на всички опити, бихме използвали този
  вектор с резултати за да си правим изводи за това какво се случва в
  симулацията.

  Когато работим с несиметрични данни ЦГТ е валидна само ако имаме достатъчно
  голям брой измервания. Нека илюстрираме това с експоненциалното
  разпределение. Знаем, че за експоненциалното разпределение, стандартното
  отклонение е равно на математическото му очакване. Съответно, ако `mu` е
  математическото очакване на експоненциално разпределена случайна величина,
  то апроксимацията му се изчислява по следната формула:

                            mean(X) - mu
                           --------------
                            mu / sqrt(n)

  В код на R това изглежда по следния начин:

    > n=1000; mu=10
    > X = rexp(n, 1/mu)
    > result = (mean(X) - mu) / (mu / sqrt(n))

  Друг начин, по който можем да разберем дали някакви данни са приблизително
  нормални е да начертаем тяхната квантил-квантил графика. Тази графика
  представя квантилите на нашите данни съпоставени с квантилите на
  нормалното разпределение. q-квантил е такава стойност, за която q*100% от
  данните са по-малки от нея. Например, медианата е 0.5-квантил, Q1 е 
  0.25-квантил, а Q3 е 0.75-квантил. Ако графиката, която сме начертали
  прилича на права линия, значи нашите данни са приблизително нормални.

    > x = rnorm(100, 0, 1); qqnorm(x)
    > x = rnorm(100, 10, 15); qqnorm(x)
    > x = rexp(100, 1/10); qqnorm(x)
    > x = runif(100, 0, 1); qqnorm(x)
